### More Effective C++

#### 指针和引用的区别

1. 不能使用指向空值的引用
2. 拒绝野指针

#### 尽量使用C++风格的类型转换

1. C++类型转换符
- static_cast
- const_cast
- dynamic_cast
- reinterpret_cast

#### 不要对数组使用多态

#### 避免无用的缺省构造函数

#### 谨慎定义类型转换函数

#### 自增、自减操作符前缀与后缀的区别

#### 不要重载“&&”，“||”，或“,”

#### 理解各种不同含义的new和delete

#### 使用析构函数防止资源泄露

- 使用智能指针代替原始指针

#### 在构造函数中防止资源泄露

#### 禁止异常信息传递到析构函数外

#### 理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”的区别

#### 通过引用（reference）捕获异常

#### 审慎使用异常规格

#### 了解异常处理的系统开销

#### 牢记80-20准则

#### 考虑使用lazy evaluation

- 延迟计算

#### 分期摊还期望的计算

#### 理解临时对象的来源

#### 协助完成返回值优化

#### 通过重载避免隐式类型转换

- 单一参数的构造函数前加explicit

#### 考虑运算符的赋值形式（op=）取代其单独形式（op）

#### 考虑变更程序库

#### 理解虚拟函数、多继承、虚基类和RTTI所需的代价

#### 将构造函数和非成员函数虚拟化

- 构造函数虚拟化，就是非构造函数可以产生构造函数一样的行为
- 非成员函数虚拟化，就是非成员通过间接调用来完成函数功能

#### 限制某个类所能产生的对象数量

#### 要求或禁止在堆中产生对象

#### 智能指针

#### 引用计数

#### 代理类

#### 让函数根据一个以上的对象来决定怎么虚拟

#### 在未来时态开发程序

#### 将非尾端类设计为抽象类

#### 如何在同一程序中混合使用C++和C

#### 让自己习惯使用标准C++语言