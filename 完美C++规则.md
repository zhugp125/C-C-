###  More Effective C++

#### 指针和引用的区别

1. 不能使用指向空值的引用
2. 拒绝野指针

#### 尽量使用C++风格的类型转换

1. C++类型转换符
- static_cast
- const_cast
- dynamic_cast
- reinterpret_cast

#### 不要对数组使用多态

#### 避免无用的缺省构造函数

#### 谨慎定义类型转换函数

#### 自增、自减操作符前缀与后缀的区别

#### 不要重载“&&”，“||”，或“,”

#### 理解各种不同含义的new和delete

#### 使用析构函数防止资源泄露

- 使用智能指针代替原始指针

#### 在构造函数中防止资源泄露

#### 禁止异常信息传递到析构函数外

#### 理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”的区别

#### 通过引用（reference）捕获异常

#### 审慎使用异常规格

#### 了解异常处理的系统开销

#### 牢记80-20准则

#### 考虑使用lazy evaluation

- 延迟计算

#### 分期摊还期望的计算

#### 理解临时对象的来源

#### 协助完成返回值优化

#### 通过重载避免隐式类型转换

- 单一参数的构造函数前加explicit

#### 考虑运算符的赋值形式（op=）取代其单独形式（op）

#### 考虑变更程序库

#### 理解虚拟函数、多继承、虚基类和RTTI所需的代价

#### 将构造函数和非成员函数虚拟化

- 构造函数虚拟化，就是非构造函数可以产生构造函数一样的行为
- 非成员函数虚拟化，就是非成员通过间接调用来完成函数功能

#### 限制某个类所能产生的对象数量

#### 要求或禁止在堆中产生对象

#### 智能指针

#### 引用计数

#### 代理类

#### 让函数根据一个以上的对象来决定怎么虚拟

#### 在未来时态开发程序

#### 将非尾端类设计为抽象类

#### 如何在同一程序中混合使用C++和C

#### 让自己习惯使用标准C++语言

### Effective C++

#### 从C转向C++

1. 尽量用const和inline而不用#define
2. 尽量用\<iostream>而不是<stdio.h>
3. 尽量用new和delete，而不是malloc和free

#### 内存管理

4. 尽量使用C++风格的注释
5. 对应的new和delete要采用相同的形式
6. 析构函数里对指针成员调用delete
7. 预先准备好内存不够的情况
8. 写operator new和operator delete时要遵循常规
9. 避免隐藏标准形式的new
10. 如果写了operator new就要同时写operator delete
11. 为需要动态分配内存的类声明一个拷贝构造函数和一个赋值操作符
12. 尽量使用初始化而不要在构造函数里赋值
13. 初始化列表中成员列出的顺序和它们在类中声明的顺序相同
14. 确定基类有虚析构函数
15. 让operator=返回*this的引用
16. 在operator=中对所有数据成员赋值
17. 在operator=中检查给自己赋值的情况

#### 类和函数：设计与声明

18. 争取使类的接口完整并且最小
19. 分清成员函数，非成员函数和友元函数
20. 避免public接口出现数据成员
21. 尽可能使用const
22. 尽量用传引用而不是传值
23. 必须返回一个对象时不要试图返回一个引用
24. 在函数重载和设定参数缺省值间慎重选择
25. 避免对指针和数字类型重载
26. 避免潜在的二义性
27. 如果不想使用隐式生成的函数就要显示地禁止它
28. 划分全局名字空间

#### 类和函数：实现

29. 避免返回内部数据的句柄
30. 避免这样的成员函数：其返回值是指向成员的非const指针或引用，但成员的访问级比这个函数要低
31. 千万不要返回局部对象的引用，也不要返回函数内部new初始化的指针的引用
32. 尽可能地推迟变量的定义
33. 明智地使用内联
34. 将文件间的编译依赖性降至最低

#### 继承和面对对象设计

35. 使公有继承体现“是一个”的含义
36. 区分接口继承和实现继承
37. 绝不要重新定义继承而来的非虚函数
38. 绝不要重新定义继承而来的缺省参数值
39. 避免“向下转换”继承层次
40. 通过分层来体现“有一个”或“用...来实现”
41. 区分继承和模板
42. 明智地使用私有继承
43. 明智地使用多继承
44. 说你想说的，理解你所说的

#### 杂项

45. 弄清C++在幕后为你所写、所调用的函数
46. 宁可编译和链接时出错，也不要运行时出错
47. 确保非局部静态对象在使用前被初始化
48. 重视编译器警告
49. 熟悉标准库
50. 提高对C++的认识